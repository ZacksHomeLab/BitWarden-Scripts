[cmdletbinding()]
param (
    [parameter(Mandatory=$false,
        Position=0)]
    [ValidateScript({(Test-Path -Path $_) -and ($_ -match "^(.*)\.yml$")})]
    [string]$ConfigFile = '/opt/bitwarden/bwdata/config.yml',

    [parameter(Mandatory,
        Position=1,
        HelpMessage="What is the URL of your BitWarden website? (e.g., bitwarden.zackshomelab.com)")]
        [ValidateScript({$_ -Match "[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)"})]
    [string]$URL,

    [parameter(Mandatory=$false,
        Position=2,
        helpMessage="What is the username of the service account for your server (e.g., bitwarden)?")]
        [ValidateNotNullOrEmpty()]
    [string]$ServiceAccount = 'bitwarden',

    [Parameter(Mandatory=$false, 
        Position=3)]
    [string]$LogFile = "./Update-BitWardenSSL.log"
)

begin {
    #region Variables

    # Retrieve the URL ourselves 
    if (-not $PSBoundParameters.containskey('URL')) {
        $URL = (Select-String -Path $ConfigFile -Pattern "URL:").tostring().split('http://')[-1]
    } else {
        # Incase someone gives http or https in their URL, remove it.
        if ($URL -match '^(http|https)://(.*)$') {
            $URL = ($URL).split('://')[-1]
        }
        
        # If someone gave a trailing '/' at the end of their URL, remove it.
        if ($URL[-1] -eq '/') {
            $URL = $URL.split('/')[0]
        }
    }

    $SERVICE_ACCOUNT = $ServiceAccount

    # Location of the cert files generated by certbot
    $LE_PRIVATE_KEY = "/etc/letsencrypt/live/$URL/privkey.pem"
    $LE_FULLCHAIN = "/etc/letsencrypt/live/$URL/fullchain.pem"
    $LE_CA_FILE = "/etc/letsencrypt/live/$URL/chain.pem"

    # Location to store the certificates in BitWarden's environment
    $BITWARDEN_SSL_PRIVATE_KEY = "/opt/bitwarden/bwdata/ssl/$URL/privkey.pem"
    $BITWARDEN_SSL_FULLCHAIN = "/opt/bitwarden/bwdata/ssl/$URL/fullchain.pem"
    $BITWARDEN_SSL_CA_FILE = "/opt/bitwarden/bwdata/ssl/$URL/chain.pem"

    $ITEMS_TO_VERIFY = @($LE_PRIVATE_KEY, $LE_FULLCHAIN, $LE_CA_FILE, $BITWARDEN_SSL_PRIVATE_KEY, $BITWARDEN_SSL_FULLCHAIN, $BITWARDEN_SSL_CA_FILE)
    $ITEMS_MISSING = @()
    #endregion



    #region Exit Codse
    $exitcode_DidNotRenew = 1
    $exitcode_NotRoot = 10
    $exitcode_MissingFiles = 11
    $exitcode_MissingCertbot = 12
    #endregion



    #region Functions
    function Write-Log {
        [CmdletBinding()]
        param (
            [Parameter(Mandatory, Position=0)]
            [ValidateNotNullOrEmpty()]
            [String]$Message,

            [Parameter(Mandatory=$false, Position=1)]
            [ValidateSet('Verbose', 'Information', 'Warning', 'Error')]
            [String]$EntryType = "Information",

            [parameter(Mandatory=$false, Position=2)]
            [ValidateNotNullOrEmpty()]
            [string]$Path = $script:LOG_FILE
        )
        
        begin {
            
            # Check if the log level an error or an error record was submitted
            if ($EntryType -eq 'Error') {
                $ErrorRecord = New-Object -TypeName System.Management.Automation.ErrorRecord -ArgumentList $Message, 'Unknown', 'NotSpecified', $null
            }
        }
        
        process {
            # Output to file
            $Line = "[$EntryType][$((Get-Date).toString('yyyy-MM-dd:hh-mm-ss'))][$env:ComputerName], $Message"
            $Line | Out-File $Path -Append
            
            switch ($EntryType) {
                'Verbose'     { Write-Verbose -Message $Message }
                'Information' { Write-Output $Message }
                'Warning'     { Write-Warning -Message $Message }
                'Error'       { Write-Error -ErrorRecord $ErrorRecord }
            }
        }
    }
    #endregion
    
    
    
    #region Pre-Reqs
    # Check if the user is root
    if ($PSVersionTable.Platform -eq "Unix") {
        if ($(whoami) -ne "root") {
            Write-Log -EntryType Warning -Message "Main: You must run this script as root, stopping."
            exit $exitcode_NotRoot
        }
    }

    # Verify certbot is installed
    if (-not (Get-Command -Name 'certbot' -ErrorAction SilentlyContinue)) {
        Write-Log -EntryType Warning -Message "Main: Missing the certbot command, is it installed?"
        exit $exitcode_MissingCertbot
    }
    #endregion
}

process {
    # Let's Renew our SSL Certificate
    Write-Log "Main: Running Certbot..."
    #/usr/bin/certbot renew

    
    # Before we do anything, let's check if our SSL Certificate updated within the last 24 hours
    if (Get-Item -path $LE_PRIVATE_KEY | Where-Object LastWriteTime -ge ((Get-Date).AddDays(-1))) {
        foreach ($Item in $ITEMS_TO_VERIFY) {
            # Verify the item exists
            if (-not (Test-Path -Path $Item)) {
                Write-Log -EntryType Warning -Message "Main: Item $Item is missing. Is your URL correct?"
                $ITEMS_MISSING += $Item
            }
        }
        if ($null -ne $ITEMS_MISSING) {
            Write-Log -EntryType Warning -Message "Main: You're missing the following items:"
            foreach ($ITEM_MISSING in $ITEMS_MISSING) {
                Write-Log -EntryType Warning "Item: $ITEM_MISSING"
            }
            exit $exitcode_MissingFiles
        }   
        Write-Log "Main: Appears that we have everything needed to proceed."


    }
} else {
    Write-Log "Main: SSL Certificate has not renewed in the last 24 hours."
    exit $exitcode_DidNotRenew
}